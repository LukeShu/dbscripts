#!/bin/bash

. "$(dirname $0)/db-functions"
. "$(dirname $0)/config"

if [ $# -lt 3 ]; then
	msg "usage: $(basename $0) <repo-from> <repo-to> <pkgname|pkgbase> ..."
	exit 1
fi

args=(${@})
repo_from="${args[0]}"
repo_to="${args[1]}"
ftppath_from="${FTP_BASE}/${repo_from}/os/"
ftppath_to="${FTP_BASE}/${repo_to}/os/"

if ! check_repo_permission $repo_to || ! check_repo_permission $repo_from; then
	die "You don't have permission to move packages from ${repo_from} to ${repo_to}"
fi

# TODO: this might lock too much (architectures)
for pkgarch in ${ARCHES[@]}; do
	repo_lock ${repo_to} ${pkgarch} || exit 1
	repo_lock ${repo_from} ${pkgarch} || exit 1
done

# No idea why we loop twice... -- fauno
for pkgbase in ${args[@]:2}; do
	for pkgarch in ${ARCHES[@]} 'any'; do
		svnrepo_from="${SVNREPO}/${repo_from}/${pkgbase}"
		if [ -r "${svnrepo_from}/PKGBUILD" ]; then
			pkgnames=($(. "${svnrepo_from}/PKGBUILD"; echo ${pkgname[@]}))
			if [ ${#pkgnames[@]} -lt 1 ]; then
				die "Could not read pkgname"
			fi

			pkgver=$(. "${svnrepo_from}/PKGBUILD"; echo $(get_full_version ${epoch:-0} ${pkgver} ${pkgrel}))
			if [ -z "${pkgver}" ]; then
				die "Could not read pkgver"
			fi

			if [ "${pkgarch}" == 'any' ]; then
				tarches=(${ARCHES[@]})
			else
				tarches=("${pkgarch}")
			fi

			for pkgname in ${pkgnames[@]}; do
				for tarch in ${tarches[@]}; do
					getpkgfile "${ftppath_from}/${tarch}/"${pkgname}-${pkgver}-${pkgarch}${PKGEXT} >/dev/null
				done
			done
			continue 2
		fi
	done
	die "${pkgbase} not found in ${repo_from}"
done

msg "Moving packages from [${repo_from}] to [${repo_to}]..."

declare -A add_pkgs
declare -A remove_pkgs
for pkgbase in ${args[@]:2}; do
	for pkgarch in ${ARCHES[@]} 'any'; do
		svnrepo_from="${SVNREPO}/${repo_from}/${pkgbase}"

		if [ -f "${svnrepo_from}/PKGBUILD" ]; then
			if [ "${pkgarch}" == 'any' ]; then
				tarches=("${ARCHES[@]}")
			else
				tarches=("${pkgarch}")
			fi
			msg2 "${pkgbase} ($(echo ${tarches[@]}))"
			pkgnames=($(. "${svnrepo_from}/PKGBUILD"; echo ${pkgname[@]}))
			pkgver=$(. "${svnrepo_from}/PKGBUILD"; echo $(get_full_version ${epoch:-0} ${pkgver} ${pkgrel}))

			for pkgname in ${pkgnames[@]}; do
				for tarch in ${tarches[@]}; do
					pkgpath=$(getpkgfile "${ftppath_from}/${tarch}/"${pkgname}-${pkgver}-${pkgarch}${PKGEXT})
					pkgfile=$(basename "${pkgpath}")

					# copy package to pool if needed
					# TODO: can be removed once every package has been moved to the package pool
					if [ ! -f ${FTP_BASE}/${PKGPOOL}/${pkgfile} ]; then
						cp ${pkgpath} ${FTP_BASE}/${PKGPOOL}
					fi
					ln -s "../../../${PKGPOOL}/${pkgfile}" ${ftppath_to}/${tarch}/
					if [ -f ${FTP_BASE}/${PKGPOOL}/${pkgfile}.sig ]; then
						ln -s "../../../${PKGPOOL}/${pkgfile}.sig" ${ftppath_to}/${tarch}/
					fi
					add_pkgs[${tarch}]+="${FTP_BASE}/${PKGPOOL}/${pkgfile} "
					remove_pkgs[${tarch}]+="${pkgname} "
				done
			done
		fi
	done
done

for tarch in ${ARCHES[@]}; do
	if [ -n "${add_pkgs[${tarch}]}" ]; then
		arch_repo_add "${repo_to}" "${tarch}" ${add_pkgs[${tarch}]}
		arch_repo_remove "${repo_from}" "${tarch}" ${remove_pkgs[${tarch}]}
	fi
done

for pkgarch in ${ARCHES[@]}; do
	repo_unlock ${repo_from} ${pkgarch}
	repo_unlock ${repo_to} ${pkgarch}
done
